{"ts":1366739996860,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":false,"ts":1366740000112,"patch":[[{"diffs":[[1,"var _ = require('underscore'),\n    jade = require('jade'),\n    fs = require('fs');\n\nfunction Template(uri) {\n  if (!(this instanceof Template))\n    return new Template(uri);\n\n    this.cachedTemplateString = \"\";\n    \n    this.uri = uri;\n    \n    this.extend = {};\n    \n    this.includes = [];\n    \n    this.load(uri);\n    \n}\n\n/**\n * Loads the file at the URI into the template string and performs the injections\n * of the extends and includes.\n * @param uri an optional uri that can be used to re-load the template with a new file.\n **/\nTemplate.prototype.load = function(uri, returnFn) {\n    if (!_.isUndefined(uri) && !_.isNull(uri)) {\n        this.uri = uri;\n    }\n    \n    // Load up the URI into the cached template string.\n    this.cachedTemplateString = fs.readFileSync(this.uri, 'utf8');\n    \n    var includes = [];\n    var extend = {};\n    \n    // Inject the includes and extends into the cachedTemplateString.\n    if (!_.isUndefined(this.includes) && !_.isNull(this.includes)) {\n        includes = this.includes;\n    };\n    \n    if (!_.isUndefined(this.extend) && !_.isNull(this.extend)) {\n        extend = this.extend;\n    }\n    \n    function processExtends() {\n        if (!_.isNull(this.extend) && !_.isUndefined(this.extend)) {\n            if (!_.isEmpty(this.extend)) {\n                var re = new RegExp(\"extends \" + this.extend.name,\"g\");\n                this.cachedTemplateString = this.cachedTemplateString.replace(re, \"extends \" + this.extend.uri);                \n            }\n        }\n        return processIncludes(0);\n    }\n        \n    function processIncludes(index) {\n        if (index < _.size(this.includes) - 1) {\n            if(!_.isUndefined(this.includes) && !_.isUndefined(this.includes) && !_.isEmpty(this.includes)) {\n                var re = new RegExp(\"include \" + this.includes[index].name,\"g\");\n                this.cachedTemplateString = this.cachedTemplateString.replace(re, \"include \" + this.includes[index].uri);           \n            }\n            // Now, call the next one.\n            processIncludes(++index);\n        } else {\n            // Now, return the cachedTemplateString\n            if (!_.isNull(returnFn) && !_.isUndefined(returnFn)) {\n                returnFn(this.cachedTemplateString);   \n            }\n            \n            return this.cachedTemplateString;            \n        }\n    }\n    \n    return processExtends();\n};\n\n/**\n * Use this method to dynamically inject layout items into a template.\n * @param obj an object with the layout extensions and inclusions.\n * @param fn a function to be called when injection is complete.\n **/\nTemplate.prototype.inject = function(object) {\n    if (!_.isUndefined(object) && !_.isNull(object)) {\n        if (!_.isUndefined(object.includes) && !_.isNull(object.includes)) {\n            this.includes = object.includes;\n        }\n        if (!_.isUndefined(object.extend) && !_.isNull(object.extend)) {\n            this.extend = object.extend;\n        }\n    }\n};\n\n/**\n * Renders the template with the given locals and calls the return function with\n * the HTML to be rendered.  Can also optionally be given a \"response\" object from express\n * to render the response.\n * @param res a response object that can render html.\n * @param locals an object with local variables to pass into the template.\n * @param a function that is called when the render is complete.  The function\n * takes an err and html parameter.\n **/\nTemplate.prototype.render = function(res, locals, fn) {\n    // first, lets check to see if this is the 2 argument version or the 3 argument version.\n    if (_.isFunction(locals)) {\n        locals = res;\n        fn = locals;\n        res = null;\n    }\n    \n    var compileConfig = {};\n    compileConfig.filename = '/';\n    if (!_.isUndefined(locals) && !_.isNull(locals)) {\n        compileConfig.locals = locals;   \n    }\n    \n    if (this.cachedTemplateString === '') {\n        this.load(this.uri);\n        compileTemplate();\n    } else {\n        compileTemplate();\n    }\n    \n    function compileTemplate() {\n        var compiledTemplate = jade.compile(this.cachedTemplateString, compileConfig);\n        console.log(\"Compiled template: \" + compiledTemplate);\n        \n        // Last part is to render and / or return the template.\n        if (!_.isUndefined(res) && !_.isNull(res)) {\n            res.send(compiledTemplate);   \n        }\n        \n        if (!_.isUndefiend(fn) && !_.isNull(fn) && _.isFunction(fn)) {\n            fn(compiledTemplate);\n        }\n    }\n};\n\nmodule.exports = Template;"]],"start1":0,"start2":0,"length1":0,"length2":4522}]],"length":4522,"saved":false}
